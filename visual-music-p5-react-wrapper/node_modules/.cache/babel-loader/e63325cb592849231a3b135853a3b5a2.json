{"ast":null,"code":"import p5 from 'p5';\nimport 'p5/lib/addons/p5.sound';\nimport 'p5/lib/addons/p5.dom';\nexport default function sketch(p) {\n  let song;\n  let fft;\n  let amplitude;\n  let volume;\n  let isPlaying = false;\n  const width = 900;\n  const height = 500;\n  const divisions = 5;\n  const speed = 1;\n  let canvas;\n\n  p.setup = function () {\n    p.background(7, 11, 21);\n    canvas = p.createCanvas(width, height);\n    fft = new p5.FFT(0.9, 256); // for the waves\n\n    amplitude = new p5.Amplitude(); // for the ellipses\n\n    p.noFill();\n    p.stroke(0, 100);\n  }; //Custom redraw that will trigger upon state change\n\n\n  p.myCustomRedrawAccordingToNewPropsHandler = function (props) {\n    if (song) {\n      if (song.isLoaded()) {\n        volume = props.volume;\n        isPlaying = props.isPlaying; //monitor volume change and toggling of pause/play button\n\n        song.setVolume(parseFloat(volume));\n        p.togglePlaying(song); //Reinitializes song if a new file is uploaded\n\n        if (song.file !== props.uploadedSong) {\n          song.dispose();\n          song = p.loadSound(props.uploadedSong);\n        }\n      }\n    } else {\n      //handles initial song load\n      if (props.uploadedSong) {\n        song = p.loadSound(props.uploadedSong);\n      }\n    }\n  };\n\n  p.togglePlaying = function (song) {\n    if (isPlaying && !song.isPlaying()) {\n      song.play();\n    } else if (!isPlaying && song.isPlaying()) {\n      song.pause();\n    }\n  };\n\n  p.draw = function () {\n    // WAVES\n    const h = height / divisions;\n    const spectrum = fft.analyze();\n    let scaledSpectrum = p.splitOctaves(spectrum, 12);\n    const spectrumLength = scaledSpectrum.length;\n    p.background(253, 155, 74, 1); // copy before clearing the background\n\n    p.copy(canvas, 0, 0, width, height, 0, speed, width, height); // draw shape\n\n    p.beginShape(); // one at the far corner\n\n    p.curveVertex(0, h);\n\n    for (let i = 0; i < spectrumLength; i++) {\n      let point = p.smoothPoint(scaledSpectrum, i, 2);\n      let x = p.map(i, 0, spectrumLength - 1, 0, width);\n      let y = p.map(point, 0, 255, h, 0);\n      p.curveVertex(x, y);\n    } // one last point at the end\n\n\n    p.curveVertex(width, h);\n    p.endShape(); // ELLIPSE 1\n\n    let songVolume = amplitude.getLevel();\n    let ellipseDiameter = p.map(songVolume, 0, 1, 40, 500); // you need the map() in order to get a big enough ellipse\n\n    if (songVolume < 0.1) {\n      p.fill(15, 167, 151);\n    } else if (songVolume < 0.2) {\n      p.fill(196, 51, 136);\n    } else {\n      p.fill(253, 155, 74);\n    }\n\n    p.ellipse(width / 2, height / 2, ellipseDiameter, ellipseDiameter); // ELLIPSE 2\n\n    let ellipseDiameter2 = p.map(songVolume, 0, 1, 60, 600);\n\n    if (songVolume < 0.01) {\n      p.fill(196, 51, 136);\n    } else if (songVolume < 0.06) {\n      p.fill(253, 155, 74);\n    } else {\n      p.fill(15, 167, 151);\n    }\n\n    p.ellipse(width / 4, height / 4, ellipseDiameter2, ellipseDiameter2);\n  };\n  /**\n   *  Divides an fft array into octaves with each\n   *  divided by three, or by a specified \"slicesPerOctave\".\n   *\n   *  There are 10 octaves in the range 20 - 20,000 Hz,\n   *  so this will result in 10 * slicesPerOctave + 1\n   *\n   *  @method splitOctaves\n   *  @param {Array} spectrum Array of fft.analyze() values\n   *  @param {Number} [slicesPerOctave] defaults to thirds\n   *  @return {Array} scaledSpectrum array of the spectrum reorganized by division\n   *                                 of octaves\n   */\n\n\n  p.splitOctaves = function (spectrum, slicesPerOctave) {\n    let scaledSpectrum = [];\n    const spectrumLength = spectrum.length; // default to thirds\n\n    let n = slicesPerOctave || 3;\n    let nthRootOfTwo = Math.pow(2, 1 / n); // the last N bins get their own\n\n    const lowestBin = slicesPerOctave;\n    let binIndex = spectrumLength - 1;\n    let i = binIndex;\n\n    while (i > lowestBin) {\n      let nextBinIndex = p.round(binIndex / nthRootOfTwo);\n      if (nextBinIndex === 1) return;\n      let total = 0;\n      let numBins = 0; // add up all of the values for the frequencies\n\n      for (i = binIndex; i > nextBinIndex; i--) {\n        total += spectrum[i];\n        numBins++;\n      } // divide total sum by number of bins\n\n\n      let energy = total / numBins;\n      scaledSpectrum.push(energy); // keep the loop going\n\n      binIndex = nextBinIndex;\n    } // add the lowest bins at the end\n\n\n    for (let j = i; j > 0; j--) {\n      scaledSpectrum.push(spectrum[j]);\n    } // reverse so that array has same order as original array (low to high frequencies)\n\n\n    scaledSpectrum.reverse();\n    return scaledSpectrum;\n  }; // average a point in an array with its neighbors\n\n\n  p.smoothPoint = function (spectrum, index, numberOfNeighbors) {\n    // default to 2 neighbors on either side\n    let neighbors = numberOfNeighbors || 2;\n    let spectrumLength = spectrum.length;\n    let val = 0; // start below the index\n\n    let indexMinusNeighbors = index - neighbors;\n    let smoothedPoints = 0;\n\n    for (let i = indexMinusNeighbors; i < index + neighbors && i < spectrumLength; i++) {\n      // if there is a point at spectrum[i], tally it\n      if (typeof spectrum[i] !== 'undefined') {\n        val += spectrum[i];\n        smoothedPoints++;\n      }\n    }\n\n    val = val / smoothedPoints;\n    return val;\n  };\n}","map":{"version":3,"sources":["/Users/Askat/LEARNING/visual-music/visual-music-p5-react-wrapper/src/vendor/sketches/sketch.js"],"names":["p5","sketch","p","song","fft","amplitude","volume","isPlaying","width","height","divisions","speed","canvas","setup","background","createCanvas","FFT","Amplitude","noFill","stroke","myCustomRedrawAccordingToNewPropsHandler","props","isLoaded","setVolume","parseFloat","togglePlaying","file","uploadedSong","dispose","loadSound","play","pause","draw","h","spectrum","analyze","scaledSpectrum","splitOctaves","spectrumLength","length","copy","beginShape","curveVertex","i","point","smoothPoint","x","map","y","endShape","songVolume","getLevel","ellipseDiameter","fill","ellipse","ellipseDiameter2","slicesPerOctave","n","nthRootOfTwo","Math","pow","lowestBin","binIndex","nextBinIndex","round","total","numBins","energy","push","j","reverse","index","numberOfNeighbors","neighbors","val","indexMinusNeighbors","smoothedPoints"],"mappings":"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","sourcesContent":["import p5 from 'p5';\nimport 'p5/lib/addons/p5.sound';\nimport 'p5/lib/addons/p5.dom';\n\nexport default function sketch(p) {\n\tlet song;\n\tlet fft;\n\tlet amplitude;\n\tlet volume;\n\tlet isPlaying = false;\n\n\tconst width = 900;\n\tconst height = 500;\n\tconst divisions = 5;\n\tconst speed = 1;\n\n\tlet canvas;\n\n\tp.setup = function() {\n\t\tp.background(7, 11, 21);\n\t\tcanvas = p.createCanvas(width, height);\n\t\tfft = new p5.FFT(0.9, 256); // for the waves\n\t\tamplitude = new p5.Amplitude(); // for the ellipses\n\t\tp.noFill();\n\t\tp.stroke(0, 100);\n\t};\n\n\t//Custom redraw that will trigger upon state change\n\tp.myCustomRedrawAccordingToNewPropsHandler = function(props) {\n\t\tif (song) {\n\t\t\tif (song.isLoaded()) {\n\t\t\t\tvolume = props.volume;\n\t\t\t\tisPlaying = props.isPlaying;\n\n\t\t\t\t//monitor volume change and toggling of pause/play button\n\t\t\t\tsong.setVolume(parseFloat(volume));\n\t\t\t\tp.togglePlaying(song);\n\n\t\t\t\t//Reinitializes song if a new file is uploaded\n\t\t\t\tif (song.file !== props.uploadedSong) {\n\t\t\t\t\tsong.dispose();\n\t\t\t\t\tsong = p.loadSound(props.uploadedSong);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//handles initial song load\n\t\t\tif (props.uploadedSong) {\n\t\t\t\tsong = p.loadSound(props.uploadedSong);\n\t\t\t}\n\t\t}\n\t};\n\n\tp.togglePlaying = function(song) {\n\t\tif (isPlaying && !song.isPlaying()) {\n\t\t\tsong.play();\n\t\t} else if (!isPlaying && song.isPlaying()) {\n\t\t\tsong.pause();\n\t\t}\n\t};\n\n\tp.draw = function() {\n\t\t// WAVES\n\t\tconst h = height / divisions;\n\t\tconst spectrum = fft.analyze();\n\n\t\tlet scaledSpectrum = p.splitOctaves(spectrum, 12);\n\t\tconst spectrumLength = scaledSpectrum.length;\n\n\t\tp.background(253, 155, 74, 1);\n\n\t\t// copy before clearing the background\n\t\tp.copy(canvas, 0, 0, width, height, 0, speed, width, height);\n\n\t\t// draw shape\n\t\tp.beginShape();\n\n\t\t// one at the far corner\n\t\tp.curveVertex(0, h);\n\n\t\tfor (let i = 0; i < spectrumLength; i++) {\n\t\t\tlet point = p.smoothPoint(scaledSpectrum, i, 2);\n\t\t\tlet x = p.map(i, 0, spectrumLength - 1, 0, width);\n\t\t\tlet y = p.map(point, 0, 255, h, 0);\n\t\t\tp.curveVertex(x, y);\n\t\t}\n\n\t\t// one last point at the end\n\t\tp.curveVertex(width, h);\n\n\t\tp.endShape();\n\n\t\t// ELLIPSE 1\n\t\tlet songVolume = amplitude.getLevel();\n\t\tlet ellipseDiameter = p.map(songVolume, 0, 1, 40, 500); // you need the map() in order to get a big enough ellipse\n\n\t\tif (songVolume < 0.1) {\n\t\t\tp.fill(15, 167, 151);\n\t\t} else if (songVolume < 0.2) {\n\t\t\tp.fill(196, 51, 136);\n\t\t} else {\n\t\t\tp.fill(253, 155, 74);\n\t\t}\n\t\tp.ellipse(width / 2, height / 2, ellipseDiameter, ellipseDiameter);\n\n\t\t// ELLIPSE 2\n\t\tlet ellipseDiameter2 = p.map(songVolume, 0, 1, 60, 600);\n\t\tif (songVolume < 0.01) {\n\t\t\tp.fill(196, 51, 136);\n\t\t} else if (songVolume < 0.06) {\n\t\t\tp.fill(253, 155, 74);\n\t\t} else {\n\t\t\tp.fill(15, 167, 151);\n\t\t}\n\t\tp.ellipse(width / 4, height / 4, ellipseDiameter2, ellipseDiameter2);\n\t};\n\n\t/**\n\t *  Divides an fft array into octaves with each\n\t *  divided by three, or by a specified \"slicesPerOctave\".\n\t *\n\t *  There are 10 octaves in the range 20 - 20,000 Hz,\n\t *  so this will result in 10 * slicesPerOctave + 1\n\t *\n\t *  @method splitOctaves\n\t *  @param {Array} spectrum Array of fft.analyze() values\n\t *  @param {Number} [slicesPerOctave] defaults to thirds\n\t *  @return {Array} scaledSpectrum array of the spectrum reorganized by division\n\t *                                 of octaves\n\t */\n\tp.splitOctaves = function(spectrum, slicesPerOctave) {\n\t\tlet scaledSpectrum = [];\n\t\tconst spectrumLength = spectrum.length;\n\n\t\t// default to thirds\n\t\tlet n = slicesPerOctave || 3;\n\t\tlet nthRootOfTwo = Math.pow(2, 1 / n);\n\n\t\t// the last N bins get their own\n\t\tconst lowestBin = slicesPerOctave;\n\n\t\tlet binIndex = spectrumLength - 1;\n\t\tlet i = binIndex;\n\n\t\twhile (i > lowestBin) {\n\t\t\tlet nextBinIndex = p.round(binIndex / nthRootOfTwo);\n\n\t\t\tif (nextBinIndex === 1) return;\n\n\t\t\tlet total = 0;\n\t\t\tlet numBins = 0;\n\n\t\t\t// add up all of the values for the frequencies\n\t\t\tfor (i = binIndex; i > nextBinIndex; i--) {\n\t\t\t\ttotal += spectrum[i];\n\t\t\t\tnumBins++;\n\t\t\t}\n\n\t\t\t// divide total sum by number of bins\n\t\t\tlet energy = total / numBins;\n\t\t\tscaledSpectrum.push(energy);\n\n\t\t\t// keep the loop going\n\t\t\tbinIndex = nextBinIndex;\n\t\t}\n\n\t\t// add the lowest bins at the end\n\t\tfor (let j = i; j > 0; j--) {\n\t\t\tscaledSpectrum.push(spectrum[j]);\n\t\t}\n\n\t\t// reverse so that array has same order as original array (low to high frequencies)\n\t\tscaledSpectrum.reverse();\n\n\t\treturn scaledSpectrum;\n\t};\n\n\t// average a point in an array with its neighbors\n\tp.smoothPoint = function(spectrum, index, numberOfNeighbors) {\n\t\t// default to 2 neighbors on either side\n\t\tlet neighbors = numberOfNeighbors || 2;\n\t\tlet spectrumLength = spectrum.length;\n\n\t\tlet val = 0;\n\n\t\t// start below the index\n\t\tlet indexMinusNeighbors = index - neighbors;\n\t\tlet smoothedPoints = 0;\n\n\t\tfor (\n\t\t\tlet i = indexMinusNeighbors;\n\t\t\ti < index + neighbors && i < spectrumLength;\n\t\t\ti++\n\t\t) {\n\t\t\t// if there is a point at spectrum[i], tally it\n\t\t\tif (typeof spectrum[i] !== 'undefined') {\n\t\t\t\tval += spectrum[i];\n\t\t\t\tsmoothedPoints++;\n\t\t\t}\n\t\t}\n\n\t\tval = val / smoothedPoints;\n\n\t\treturn val;\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}